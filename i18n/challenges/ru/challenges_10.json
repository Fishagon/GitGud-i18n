[
  {
    "id": 91,
    "title": "Автоматически подписывать коммиты с помощью GPG",
    "description": "GPG (GNU Privacy Guard) позволяет криптографически подписывать ваши коммиты для проверки их подлинности. Это гарантирует, что коммиты действительно от вас и не были изменены. Настройте Git на автоматическую подпись всех коммитов вашим GPG-ключом.\n\nНастройка подписи коммитов GPG:\n1. Настройте ключ подписи GPG (используйте 'ABC123DEF456' как ID ключа)\n2. Включите автоматическую подпись коммитов\n3. Сделайте подписанный коммит для проверки конфигурации",
    "difficulty": "Средне",
    "category": "Эксперт",
    "hints": [
      "Используйте 'git config --global user.signingkey <key-id>', чтобы задать ключ подписи GPG.",
      "Используйте 'git config --global commit.gpgsign true', чтобы включить автоматическую подпись коммитов.",
      "ID ключа для этого упражнения: 'ABC123DEF456'.",
      "Сделайте коммит после настройки, чтобы проверить подпись.",
      "Проверить GPG-настройки: 'git config --list | grep gpg'."
    ]
  },
  {
    "id": 92,
    "title": "Объединить несколько коммитов в один при слиянии ветки",
    "description": "Иногда нужно слить feature-ветку, сохранив чистую историю, объединяя все коммиты из этой ветки в один. Это называется 'squash merge' и выполняется с помощью 'git merge --squash'.\n\nВетка 'feature-cleanup' содержит несколько мелких коммитов, которые должны быть объединены в один при слиянии в main. Выполните squash merge, чтобы объединить все коммиты из 'feature-cleanup' в один коммит с сообщением 'Implement cleanup feature'.",
    "difficulty": "Средне",
    "category": "Эксперт",
    "hints": [
      "Используйте 'git merge --squash feature-cleanup', чтобы объединить все коммиты из ветки.",
      "После squash merge изменения индексируются, но коммит ещё не создан.",
      "Используйте 'git commit -m \"Implement cleanup feature\"', чтобы создать итоговый объединённый коммит.",
      "Проверьте 'git log --oneline', чтобы увидеть, что добавился только один коммит вместо нескольких.",
      "Оригинальные коммиты из feature-ветки не появятся в истории ветки main."
    ]
  },
  {
    "id": 93,
    "title": "Переписать историю ветки и выполнить принудительную отправку",
    "description": "Иногда нужно очистить историю коммитов перед публикацией. Это включает переписывание истории (с помощью интерактивного rebase), а затем принудительную отправку изменений для обновления удалённой ветки. Полезно для squash-коммитов, исправления сообщений или переупорядочивания коммитов перед слиянием.\n\nПерепишите историю текущей ветки, объединив последние 2 коммита в 1, затем выполните принудительную отправку изменений в удалённый репозиторий.",
    "difficulty": "Сложно",
    "category": "Эксперт",
    "hints": [
      "Используйте 'git rebase -i HEAD~2', чтобы начать интерактивное перебазирование последних 2 коммитов.",
      "Замените 'pick' на 'squash' (или 's') для второго коммита, чтобы объединить его с первым.",
      "После завершения rebase используйте 'git push --force' или 'git push -f', чтобы обновить удалённую ветку.",
      "Будьте осторожны с force push — он переписывает удалённую историю и может затронуть других участников.",
      "Можно использовать 'git push --force-with-lease' для более безопасной отправки."
    ]
  },
  {
    "id": 94,
    "title": "Удалить чувствительные данные из истории с помощью git filter-branch",
    "description": "Иногда в репозиторий по ошибке попадает конфиденциальная информация: пароли, API-ключи или персональные данные. Простое удаление файла новым коммитом недостаточно — чувствительные данные останутся в истории Git и будут доступны всем, у кого есть доступ к репозиторию.\n\nФайл 'secrets.txt' с чувствительными API-ключами по ошибке закоммичен в историю. Используйте 'git filter-branch', чтобы полностью удалить этот файл из всех коммитов истории, и убедитесь, что пустые коммиты удалены.\n\n Важно: эта операция переписывает историю и должна выполняться осторожно в общих репозиториях. Предпочтительно использовать внешний инструмент вроде filter-repo.",
    "difficulty": "Сложно",
    "category": "Эксперт",
    "hints": [
      "Используйте 'git filter-branch --tree-filter \"rm -f secrets.txt\" --prune-empty --all', чтобы удалить файл из истории.",
      "Флаг --tree-filter выполняет команды в рабочем каталоге каждого коммита.",
      "Флаг --prune-empty удаляет коммиты, ставшие пустыми после фильтрации.",
      "Флаг --all гарантирует обработку всех веток.",
      "Альтернатива: используйте --index-filter 'git rm --cached --ignore-unmatch secrets.txt' для лучшей производительности.",
      "После фильтрации файл не должен присутствовать ни в одном коммите истории."
    ]
  },
  {
    "id": 95,
    "title": "Переписать историю с помощью git rebase -i на нескольких ветках",
    "description": "В сложных проектах часто требуется приводить историю коммитов в порядок на нескольких ветках перед слиянием. В проекте есть две feature-ветки, которым нужно очистить историю коммитов.\n\nЗадачи:\n1. Переключитесь на ветку 'feature-cleanup' и используйте интерактивное перебазирование, чтобы объединить последние 3 коммита в 1\n2. Переключитесь на ветку 'feature-refactor' и перебазируйте её на ветку 'main'\n3. Используйте интерактивное перебазирование на 'feature-refactor', чтобы переупорядочить коммиты так, чтобы 'refactor tests' шёл перед 'refactor code'\n\nЭто моделирует подготовку нескольких feature-веток к чистому слиянию в main.",
    "difficulty": "Сложно",
    "category": "Эксперт",
    "hints": [
      "Используйте 'git checkout feature-cleanup', чтобы переключиться на первую ветку.",
      "Используйте 'git rebase -i HEAD~3', чтобы начать интерактивное перебазирование последних 3 коммитов.",
      "Замените 'pick' на 'squash' или 's' для коммитов, которые хотите объединить.",
      "Переключитесь на 'git checkout feature-refactor'.",
      "Используйте 'git rebase main', чтобы перебазировать feature-refactor на main.",
      "Используйте 'git rebase -i HEAD~2', чтобы переупорядочить последние 2 коммита.",
      "В списке rebase можно двигать строки вверх/вниз для смены порядка."
    ]
  },
  {
    "id": 96,
    "title": "Настроить Git-сервер для хостинга собственных репозиториев",
    "description": "Настройка собственного Git-сервера позволяет приватно размещать репозитории и управлять доступом. Можно использовать встроенный демон Git для простого сервиса или развернуть более продвинутые решения.\n\nСоздайте голый репозиторий 'project.git', затем запустите демон Git на порту по умолчанию (9418) с включённым receive-pack, чтобы другие могли выполнять push.",
    "difficulty": "Сложно",
    "category": "Эксперт",
    "hints": [
      "Используйте 'git init --bare project.git', чтобы создать голый репозиторий.",
      "Запустите демон Git: 'git daemon --base-path=. --enable=receive-pack'.",
      "Голые репозитории не имеют рабочего каталога — они хранят только данные Git.",
      "Флаг --enable=receive-pack позволяет другим выполнять push на ваш сервер.",
      "Проверьте сервер, клонировав: 'git clone git://localhost/project.git'."
    ]
  },
  {
    "id": 97,
    "title": "Преобразовать существующий репозиторий Git в голый",
    "description": "Иногда нужно преобразовать обычный репозиторий (с рабочим каталогом) в голый для совместного использования или для сервера. Голый репозиторий содержит только данные Git без рабочего каталога.\n\nУ вас есть обычный репозиторий с несколькими коммитами. Преобразуйте его в голый репозиторий по пути '../project-bare.git', сохранив все коммиты и ветки.",
    "difficulty": "Средне",
    "category": "Эксперт",
    "hints": [
      "Используйте 'git clone --bare . ../project-bare.git', чтобы создать голый клон текущего репозитория.",
      "Голый репозиторий не имеет рабочего каталога — только данные Git.",
      "Можно также использовать 'git clone --mirror', чтобы включить все refs и remotes.",
      "После конвертации проверьте 'git config core.bare' в новом репозитории.",
      "Голые репозитории обычно имеют суффикс .git."
    ]
  },
  {
    "id": 98,
    "title": "Использовать git rev-list с продвинутыми параметрами",
    "description": "Команда `git rev-list` — это мощный низкоуровневый инструмент для обхода истории коммитов. Она поддерживает множество опций фильтрации и форматирования, что делает её чрезвычайно гибкой для анализа истории репозитория.\n\nИспользуйте `git rev-list` со следующими опциями, объединёнными в одной команде:\n- Посчитать коммиты вместо их перечисления\n- Отфильтровать только коммиты авторов, содержащих 'john'\n- Искать слово 'fix' в сообщениях коммитов\n- Исключить merge-коммиты из результатов\n\nЭта комбинация вернёт количество немерджевых коммитов авторов, содержащих 'john', где в сообщении встречается 'fix'.",
    "difficulty": "Средне",
    "category": "Эксперт",
    "hints": [
      "Флаг --count заставляет rev-list возвращать только число совпадающих коммитов.",
      "Флаг --author фильтрует коммиты по имени автора (частичные совпадения работают).",
      "Флаг --grep ищет текст в сообщениях коммитов.",
      "Флаг --no-merges исключает merge-коммиты из результатов.",
      "Все эти опции можно объединить в одной команде rev-list.",
      "Используйте 'git rev-list --count --author=\"john\" --grep=\"fix\" --no-merges HEAD'."
    ]
  },
  {
    "id": 99,
    "title": "Найти все базовые коммиты с помощью git merge-base --all",
    "description": "В сложных репозиториях с несколькими точками слияния может быть больше одного базового коммита между ветками. Используйте git merge-base с флагом --all, чтобы найти все возможные базовые коммиты между тремя feature-ветками.\n\nНайдите все базовые коммиты между 'feature-x', 'feature-y' и 'feature-z' одной командой с флагом --all. Это покажет все общие предки, общие для этих веток.",
    "difficulty": "Сложно",
    "category": "Эксперт",
    "hints": [
      "Используйте 'git merge-base --all feature-x feature-y feature-z', чтобы найти всех общих предков.",
      "Флаг --all показывает каждый базовый коммит, а не только лучший.",
      "В сложной истории слияний базовых коммитов может быть несколько.",
      "Можно визуализировать структуру с помощью 'git log --graph --oneline --all'."
    ]
  },
  {
    "id": 100,
    "title": "Освоить Git Clean — финальное испытание",
    "description": "Поздравляем с достижением финального испытания! В вашем репозитории накопились различные неотслеживаемые файлы и каталоги, которые нужно стратегически очистить.\n\nУ вас есть:\n- Неотслеживаемые исходные файлы, которые следует удалить\n- Неотслеживаемые каталоги, которые нужно почистить\n- Некоторые игнорируемые файлы (артефакты сборки), которые тоже следует удалить\n- Конкретный файл 'important-notes.txt', который нужно сохранить\n\nВыполните комплексную очистку, которая удалит неотслеживаемые файлы и каталоги, включая игнорируемые файлы, но исключит важный файл.",
    "difficulty": "Сложно",
    "category": "Очистка и обслуживание",
    "hints": [
      "Нужно использовать несколько флагов: -f (force), -d (directories), -x (ignored files).",
      "Используйте -e, чтобы исключить файл important-notes.txt из очистки.",
      "Полная команда: git clean -fdx -e important-notes.txt",
      "Эта операция удаляет неотслеживаемые файлы, каталоги и игнорируемые файлы, сохраняя исключённый файл."
    ]
  }
]