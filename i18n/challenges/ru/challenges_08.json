[
  {
    "id": 71,
    "title": "Получить изменения из удалённого репозитория без слияния",
    "description": "Иногда нужно увидеть, какие изменения доступны в удалённом репозитории, не сливая их сразу в вашу текущую ветку. Команда 'git fetch' загружает изменения, но не выполняет слияние, позволяя сначала их просмотреть.\n\nПолучите последние изменения из удалённого 'origin', не сливая их в текущую ветку.",
    "difficulty": "Легко",
    "category": "Совместная работа",
    "hints": [
      "Используйте 'git fetch origin', чтобы загрузить изменения из удалённого origin.",
      "В отличие от 'git pull', fetch не сливает изменения в вашу текущую ветку.",
      "После fetch можно использовать 'git log origin/main', чтобы посмотреть доступные изменения.",
      "Используйте 'git status', чтобы увидеть, что ваша локальная ветка отстаёт от удалённой."
    ]
  },
  {
    "id": 72,
    "title": "Сбросить локальные изменения, чтобы соответствовать удалённой ветке",
    "description": "Иногда ваша локальная ветка расходится с удалённой, и вы хотите отбросить все локальные изменения, чтобы в точности соответствовать состоянию на удалённой ветке. Это полезно, когда вы отказываетесь от локальной работы и синхронизируетесь с удалённым состоянием.\n\nУ вас есть локальные изменения, конфликтующие с веткой 'origin/main'. Сбросьте локальную ветку, чтобы она точно соответствовала удалённой.",
    "difficulty": "Средне",
    "category": "Совместная работа",
    "hints": [
      "Сначала используйте 'git fetch', чтобы получить последние изменения с удалённого.",
      "Используйте 'git reset --hard origin/main', чтобы сбросить локальную ветку до состояния удалённой.",
      "Это удалит все локальные изменения и коммиты, которых нет на удалённой ветке.",
      "Осторожно — эту операцию сложно отменить!"
    ]
  },
  {
    "id": 73,
    "title": "Объединить удалённые изменения, сохранив локальные",
    "description": "У вас есть локальные изменения в рабочем каталоге, но появились и новые изменения в удалённом репозитории. Нужно объединить удалённые изменения, сохранив локальную работу. Это можно сделать, временно сохранив изменения (stash), выполнив pull, а затем вернув stash, либо предварительно закоммитив изменения.\n\nУ вас есть локальные модификации, а на удалённом появились новые коммиты. Объедините удалённые изменения, сохранив ваши локальные.",
    "difficulty": "Средне",
    "category": "Совместная работа",
    "hints": [
      "Можно использовать 'git stash' для временного сохранения локальных изменений.",
      "После сохранения выполните 'git pull', чтобы получить удалённые изменения.",
      "Затем используйте 'git stash pop', чтобы восстановить локальные изменения.",
      "Либо сначала закоммитьте локальные изменения, а затем выполните pull.",
      "Используйте 'git status', чтобы проверить состояние рабочего каталога."
    ]
  },
  {
    "id": 74,
    "title": "Перенести (cherry-pick) коммит из другой ветки",
    "description": "Иногда нужно применить конкретный коммит из одной ветки в другую, не сливая всю ветку целиком. Команда 'git cherry-pick' позволяет скопировать коммит из одной ветки и применить его к текущей.\n\nУ вас есть feature-ветка с полезным коммитом, который нужно применить к основной ветке. Выполните cherry-pick коммита с ID 'abc1234' из feature-ветки в текущую ветку.",
    "difficulty": "Средне",
    "category": "Совместная работа",
    "hints": [
      "Используйте 'git log feature-branch', чтобы увидеть коммиты в feature-ветке.",
      "Используйте 'git cherry-pick <commit-id>', чтобы применить конкретный коммит к текущей ветке.",
      "Перед cherry-pick убедитесь, что вы на целевой ветке.",
      "Cherry-pick создаёт новый коммит с теми же изменениями, но другим ID."
    ]
  },
  {
    "id": 75,
    "title": "Принудительно отправить изменения после переписывания истории",
    "description": "После переписывания истории (например, rebase или amend) ваша локальная ветка разойдётся с удалённой. Обычная отправка будет отклонена, поэтому нужно использовать принудительную отправку (force push), чтобы перезаписать историю на удалённой ветке. Это потенциально опасно, так как может перезаписать чужую работу.\n\nВы переписали историю локально и нужно принудительно отправить изменения, чтобы обновить удалённую ветку 'origin'.",
    "difficulty": "Сложно",
    "category": "Совместная работа",
    "hints": [
      "Используйте 'git push --force' или 'git push -f', чтобы выполнить принудительную отправку.",
      "Force push перезаписывает удалённую ветку вашей локальной версией.",
      "Будьте очень осторожны — вы можете перезаписать чужую работу!",
      "Можно использовать 'git push --force-with-lease' для более безопасной принудительной отправки.",
      "Проверьте 'git log --oneline', чтобы убедиться в корректности истории перед отправкой."
    ]
  },
  {
    "id": 76,
    "title": "Отправить и настроить upstream для новой удалённой ветки",
    "description": "Когда вы создаёте локальную ветку и хотите впервые отправить её в удалённый репозиторий, нужно настроить связь отслеживания (upstream). Это позволит в дальнейшем использовать 'git push' и 'git pull' без указания удалённого и имени ветки.\n\nУ вас есть локальная ветка 'feature-login' с коммитами, которую нужно отправить в удалённый репозиторий. Используйте git push с флагом upstream, чтобы создать удалённую ветку и настроить отслеживание одной командой.",
    "difficulty": "Легко",
    "category": "Совместная работа",
    "hints": [
      "Используйте 'git push --set-upstream origin feature-login', чтобы отправить и настроить upstream одной командой.",
      "Также можно использовать сокращение 'git push -u origin feature-login'.",
      "Это создаст удалённую ветку и настроит отслеживание, чтобы в будущем 'push' не требовал указания удалённого.",
      "Убедитесь, что вы на ветке 'feature-login' при выполнении команды."
    ]
  },
  {
    "id": 77,
    "title": "Настроить upstream на существующую удалённую ветку",
    "description": "Иногда у вас есть локальная ветка, которая должна отслеживать существующую удалённую ветку, но связь отслеживания ещё не настроена. Это часто случается, когда вы создаёте локальную ветку из удалённой или работаете с ветками, созданными другими.\n\nУ вас есть локальная ветка 'feature-auth', и уже существует удалённая ветка 'origin/feature-auth'. Настройте локальную ветку на отслеживание существующей удалённой ветки.",
    "difficulty": "Легко",
    "category": "Совместная работа",
    "hints": [
      "Используйте 'git branch -u origin/feature-auth', чтобы настроить upstream для текущей ветки.",
      "Можно также использовать 'git branch --set-upstream-to=origin/feature-auth feature-auth' для большей явности.",
      "Убедитесь, что вы на ветке 'feature-auth', либо укажите имя ветки в команде.",
      "Не используйте 'git push -u' для этого задания — оно предназначено для создания новых удалённых веток."
    ]
  },
  {
    "id": 78,
    "title": "Перебазировать feature-ветку на main",
    "description": "У вас есть feature-ветка, созданная от более старой версии main. С тех пор в main появились новые коммиты. Перебазирование вашей feature-ветки на актуальный main поддерживает чистую линейную историю, переигрывая коммиты feature поверх последних коммитов main, избегая лишних merge-коммитов. Это также гарантирует, что ваша фича работает с актуальными изменениями и упрощает чтение истории проекта.\n\nПереключитесь на ветку 'feature-payment' и перебазируйте её на 'main', чтобы обновить основу.",
    "difficulty": "Средне",
    "category": "Совместная работа",
    "hints": [
      "Сначала переключитесь на feature-ветку командой 'git checkout feature-payment'.",
      "Затем используйте 'git rebase main', чтобы перебазировать feature-ветку на main.",
      "Это переиграет ваши коммиты feature поверх последних коммитов main.",
      "Если возникнут конфликты, разрешите их и выполните 'git rebase --continue'."
    ]
  },
  {
    "id": 79,
    "title": "Безопасная работа в состоянии detached HEAD",
    "description": "Когда вы делаете checkout конкретного коммита, вы попадаете в состояние 'detached HEAD', где вы не на какой-либо ветке. Это полезно для изучения старого кода или тестирования, но любые коммиты здесь могут быть потеряны, если их не сохранить правильно. Безопасный способ работы в detached HEAD — создать новую ветку, если хотите сохранить изменения.\n\nСделайте checkout коммита 'abc5678', чтобы войти в состояние detached HEAD, затем создайте новую ветку 'exploration', чтобы безопасно продолжить работу.",
    "difficulty": "Средне",
    "category": "Совместная работа",
    "hints": [
      "Используйте 'git checkout abc5678', чтобы сделать checkout конкретного коммита (это переведёт в detached HEAD).",
      "Git предупредит о состоянии detached HEAD — это нормально.",
      "Создайте новую ветку 'git checkout -b exploration' или 'git switch -c exploration'.",
      "Так вы обезопасите свои будущие коммиты от потери."
    ]
  },
  {
    "id": 80,
    "title": "Синхронизировать форк с исходным репозиторием (upstream)",
    "description": "В совместной разработке часто используется форк исходного репозитория. Ваш форк (origin) может устаревать, когда оригинальный репозиторий (upstream) получает новые коммиты. Нужно синхронизировать форк с upstream, чтобы оставаться в актуальном состоянии.\n\nУ вас форк репозитория: 'origin' указывает на ваш форк, а 'upstream' — на оригинальный репозиторий. В upstream есть новые коммиты, которые нужно подтянуть локально и отправить в ваш форк для синхронизации.",
    "difficulty": "Средне",
    "category": "Совместная работа",
    "hints": [
      "Сначала получите последние изменения из upstream командой 'git fetch upstream'.",
      "Убедитесь, что вы на основной ветке: 'git checkout main'.",
      "Слейте изменения из upstream: 'git merge upstream/main'.",
      "Отправьте обновлённую main в ваш форк: 'git push origin main'.",
      "Такой рабочий процесс держит ваш форк синхронизированным с оригинальным репо."
    ]
  }
]