[
	{
		"id": 91,
		"title": "Автоматично підписувати коміти GPG",
		"description": "GPG підписання додає криптографічну автентичність до ваших комітів, доводячи, що вони дійсно були створені вами. Це особливо важливо для open source проєктів та корпоративних середовищ.\n\nНалаштуйте Git для автоматичного підписання всіх комітів за допомогою вашого GPG ключа.",
		"difficulty": "Середньо",
		"category": "Експерт",
		"hints": [
			"Спочатку переконайтеся, що у вас є GPG ключ, використовуючи 'gpg --list-secret-keys'.",
			"Налаштуйте Git використовувати ваш GPG ключ: 'git config --global user.signingkey <key-id>'.",
			"Увімкніть автоматичне підписання: 'git config --global commit.gpgsign true'."
		]
	},
	{
		"id": 92,
		"title": "Об'єднати кілька комітів в один під час злиття гілки",
		"description": "Squash merge об'єднує всі коміти з гілки функціональності в один коміт під час злиття. Це створює чистішу історію проєкту, особливо для завершених функцій.\n\nВикористайте squash merge, щоб злити гілку 'feature-branch' в 'main', об'єднавши всі її коміти в один коміт.",
		"difficulty": "Середньо",
		"category": "Експерт",
		"hints": [
			"Переключіться на гілку main командою 'git checkout main'.",
			"Використайте 'git merge --squash feature-branch', щоб підготувати squash merge.",
			"Зафіксуйте результат командою 'git commit -m \"Descriptive message\"'."
		]
	},
	{
		"id": 93,
		"title": "Переписати історію гілки та примусово відправити",
		"description": "Іноді потрібно повністю переписати історію гілки для очищення комітів, видалення чутливих даних або реорганізації розробки. Це потужна, але потенційно небезпечна операція.\n\nВикористайте інтерактивний rebase, щоб переписати історію поточної гілки, а потім примусово відправте зміни до віддаленого репозиторія.",
		"difficulty": "Важко",
		"category": "Експерт",
		"hints": [
			"Використайте 'git rebase -i HEAD~<n>', щоб почати інтерактивний rebase.",
			"Змініть коміти за потреби (squash, reword, drop тощо).",
			"Використайте 'git push --force-with-lease', щоб безпечно примусово відправити."
		]
	},
	{
		"id": 94,
		"title": "Використати git filter-branch для видалення чутливих даних з історії",
		"description": "Коли чутливі дані (паролі, ключі) випадково потрапляють до історії Git, їх потрібно повністю видалити. Git filter-branch може переписати всю історію для видалення файлів або даних.\n\nВикористайте git filter-branch, щоб видалити файл 'secrets.txt' з усієї історії репозиторія.",
		"difficulty": "Важко",
		"category": "Експерт",
		"hints": [
			"Використайте 'git filter-branch --force --index-filter'.",
			"Команда буде схожою на: 'git filter-branch --index-filter \"git rm --cached --ignore-unmatch secrets.txt\" HEAD'.",
			"Будьте обережні — це переписує всю історію!"
		]
	},
	{
		"id": 95,
		"title": "Переписати історію комітів з використанням git rebase -i через кілька гілок",
		"description": "Розширене використання інтерактивного rebase дозволяє переписувати історію через кілька гілок та точок розгалуження. Це потребує глибокого розуміння Git та може бути ризикованим.\n\nВикористайте інтерактивний rebase, щоб переписати історію, що охоплює кілька гілок, очистивши коміти та реорганізувавши структуру.",
		"difficulty": "Важко",
		"category": "Експерт",
		"hints": [
			"Ідентифікуйте базовий коміт, де почалося розгалуження.",
			"Використайте 'git rebase -i <base-commit>', щоб почати комплексний rebase.",
			"Будьте готові вирішувати конфлікти та використовувати 'git rebase --continue'."
		]
	},
	{
		"id": 96,
		"title": "Налаштувати Git сервер для розміщення ваших власних репозиторіїв",
		"description": "Налаштування власного Git сервера дає вам повний контроль над вашими репозиторіями. Це корисно для приватних проєктів, корпоративних середовищ або коли потрібен спеціальний доступ.\n\nСтворіть базовий Git сервер, який може приймати push та надавати доступ до репозиторіїв через SSH.",
		"difficulty": "Важко",
		"category": "Експерт",
		"hints": [
			"Створіть голий репозиторій на сервері за допомогою 'git init --bare'.",
			"Налаштуйте SSH доступ для користувачів Git.",
			"Переконайтеся, що дозволи файлів налаштовані правильно для спільного доступу."
		]
	},
	{
		"id": 97,
		"title": "Конвертувати існуючий Git репозиторій в голий репозиторій",
		"description": "Голі репозиторії не мають робочого дерева і використовуються для спільного доступу та як центральні репозиторії. Іноді потрібно конвертувати звичайний репозиторій в голий.\n\nКонвертуйте поточний репозиторій в голий репозиторій, зберігши всю історію та гілки.",
		"difficulty": "Середньо",
		"category": "Експерт",
		"hints": [
			"Використайте 'git config --bool core.bare true', щоб позначити репозиторій як голий.",
			"Видаліть робочий каталог та індексний файл.",
			"Перемістіть вміст .git директорії в кореневу директорію репозиторія."
		]
	},
	{
		"id": 98,
		"title": "Використати git rev-list з розширеними параметрами фільтрації",
		"description": "Git rev-list — це низькорівневий інструмент для перегляду комітів з потужними опціями фільтрації. Він може фільтрувати за датою, автором, змінами файлів та багатьма іншими критеріями.\n\nВикористайте git rev-list з розширеними фільтрами, щоб знайти коміти, зроблені конкретним автором за останній місяць.",
		"difficulty": "Середньо",
		"category": "Експерт",
		"hints": [
			"Використайте 'git rev-list --author=\"Author Name\" --since=\"1 month ago\" HEAD'.",
			"Ви можете додати --pretty для більш читабельного виводу.",
			"Експериментуйте з іншими опціями, такими як --grep, --before, --after."
		]
	},
	{
		"id": 99,
		"title": "Знайти всі основи злиття з git merge-base --all",
		"description": "В складних історіях з кількома злиттями може бути кілька основ злиття між двома гілками. Git merge-base --all знаходить всі спільні предки двох або більше комітів.\n\nВикористайте git merge-base --all, щоб знайти всі спільні основи злиття між гілками 'main' та 'feature'.",
		"difficulty": "Важко",
		"category": "Експерт",
		"hints": [
			"Використайте 'git merge-base --all main feature', щоб знайти всі основи злиття.",
			"Це покаже всі коміти, які є спільними предками обох гілок.",
			"Порівняйте з 'git merge-base main feature', щоб побачити різницю."
		]
	},
	{
		"id": 100,
		"title": "Освоїти Git Clean - Фінальний виклик",
		"description": "Вітаємо з досягненням фінального виклику! Git clean видаляє неві відстежувані файли з робочого дерева. Це корисно для очищення збірних артефактів, тимчасових файлів або після переключення гілок.\n\nДемонструйте повне володіння Git, використовуючи git clean з різними опціями для очищення вашого робочого дерева. Покажіть, що ви розумієте, як безпечно видаляти неві відстежувані файли.",
		"difficulty": "Важко",
		"category": "Очищення та обслуговування",
		"hints": [
			"Спочатку використайте 'git clean -n', щоб побачити, що буде видалено (dry run).",
			"Використайте 'git clean -f', щоб видалити неві відстежувані файли.",
			"Використайте 'git clean -fd', щоб видалити файли та директорії.",
			"Використайте 'git clean -fX', щоб видалити лише ігноровані файли.",
			"Будьте обережні — git clean назавжди видаляє файли!"
		]
	}
]