[
	{
		"id": 71,
		"title": "Завантажити зміни з віддаленого репозиторія без їх злиття",
		"description": "Іноді ви хочете побачити, які зміни доступні у віддаленому репозиторії, не зливаючи їх негайно у вашу поточну гілку. Команда 'git fetch' завантажує зміни, але не зливає їх, дозволяючи вам спочатку переглянути їх.\n\nЗавантажте останні зміни з віддаленого репозиторія 'origin' без злиття їх у вашу поточну гілку.",
		"difficulty": "Легко",
		"category": "Співпраця",
		"hints": [
			"Використайте 'git fetch origin', щоб завантажити зміни з віддаленого репозиторія origin.",
			"На відміну від 'git pull', fetch не зливає зміни у вашу поточну гілку.",
			"Після завантаження ви можете використовувати 'git log origin/main', щоб побачити, які зміни доступні.",
			"Використайте 'git status', щоб побачити, що ваша локальна гілка відстає від віддаленої."
		]
	},
	{
		"id": 72,
		"title": "Скинути локальні зміни, щоб відповідати віддаленій гілці",
		"description": "Іноді ваша локальна гілка розбіглася з віддаленою гілкою, і ви хочете відкинути всі локальні зміни, щоб точно відповідати тому, що є на віддаленому сервері. Це корисно, коли ви хочете відмовитися від локальної роботи та синхронізуватися зі станом віддаленого репозиторія.\n\nУ вас є локальні зміни, які конфліктують з віддаленою гілкою 'origin/main'. Скиньте вашу локальну гілку, щоб точно відповідати віддаленій гілці.",
		"difficulty": "Середньо",
		"category": "Співпраця",
		"hints": [
			"Спочатку використайте 'git fetch', щоб отримати останні віддалені зміни.",
			"Використайте 'git reset --hard origin/main', щоб скинути вашу локальну гілку до віддаленої.",
			"Це відкине всі локальні зміни та коміти, яких немає на віддаленому сервері.",
			"Будьте обережні — цю операцію неможливо легко скасувати!"
		]
	},
	{
		"id": 73,
		"title": "Злити віддалені зміни, зберігши локальні зміни недоторканими",
		"description": "У вас є локальні зміни у вашому робочому каталозі, але є також нові зміни у віддаленому репозиторії. Вам потрібно злити віддалені зміни, зберігши вашу локальну роботу. Це можна зробити, приховавши ваші зміни, отримавши зміни, а потім відновивши схов, або спочатку зафіксувавши ваші зміни.\n\nУ вас є локальні модифікації, а у віддаленому репозиторії є нові коміти. Зліть віддалені зміни, зберігши ваші локальні зміни недоторканими.",
		"difficulty": "Середньо",
		"category": "Співпраця",
		"hints": [
			"Ви можете використовувати 'git stash', щоб тимчасово зберегти ваші локальні зміни.",
			"Після приховування використайте 'git pull', щоб отримати віддалені зміни.",
			"Потім використайте 'git stash pop', щоб відновити ваші локальні зміни.",
			"Альтернативно, ви можете спочатку зафіксувати ваші локальні зміни, а потім отримати зміни.",
			"Використайте 'git status', щоб перевірити стан вашого робочого каталогу."
		]
	},
	{
		"id": 74,
		"title": "Перенести коміт з іншої гілки",
		"description": "Іноді потрібно застосувати конкретний коміт з однієї гілки до іншої без злиття всієї гілки. Команда 'git cherry-pick' дозволяє скопіювати коміт з однієї гілки та застосувати його до вашої поточної гілки.\n\nУ вас є гілка функціональності з корисним комітом, який ви хочете застосувати до вашої основної гілки. Перенесіть коміт з ID 'abc1234' з гілки функціональності до вашої поточної гілки.",
		"difficulty": "Середньо",
		"category": "Співпраця",
		"hints": [
			"Використайте 'git log feature-branch', щоб побачити коміти на гілці функціональності.",
			"Використайте 'git cherry-pick <commit-id>', щоб застосувати конкретний коміт до вашої поточної гілки.",
			"Переконайтеся, що ви на цільовій гілці перед перенесенням.",
			"Перенесення створює новий коміт з тими самими змінами, але з іншим ID коміту."
		]
	},
	{
		"id": 75,
		"title": "Примусово відправити після переписування історії",
		"description": "Після переписування історії Git (як з rebase або amend) ваша локальна гілка розбіжиться з віддаленою гілкою. Звичайне відправлення буде відхилено, тому потрібно використовувати примусове відправлення, щоб перезаписати віддалену історію. Це потенційно небезпечно, оскільки може перезаписати роботу інших людей.\n\nВи переписали історію комітів локально і потребуєте примусово відправити ваші зміни, щоб оновити віддалену гілку. Використайте примусове відправлення, щоб оновити віддалений репозиторій 'origin'.",
		"difficulty": "Важко",
		"category": "Співпраця",
		"hints": [
			"Використайте 'git push --force' або 'git push -f', щоб примусово відправити ваші зміни.",
			"Примусове відправлення перезаписує віддалену гілку вашою локальною версією.",
			"Будьте дуже обережні з примусовим відправленням — це може перезаписати роботу інших людей!",
			"Ви можете використовувати 'git push --force-with-lease' для безпечнішого примусового відправлення.",
			"Перевірте 'git log --oneline', щоб побачити вашу переписану історію перед відправленням."
		]
	},
	{
		"id": 76,
		"title": "Відправити та встановити upstream для нової віддаленої гілки",
		"description": "Коли ви створюєте локальну гілку і хочете відправити її до віддаленого репозиторія вперше, потрібно налаштувати відстежувальний зв'язок upstream. Це дозволяє майбутнім командам `git push` та `git pull` працювати без вказування імен віддаленого репозиторія та гілки.\n\nУ вас є локальна гілка 'feature-login' з деякими комітами, яку потрібно відправити до віддаленого репозиторія. Використайте git push з прапорцем upstream, щоб створити віддалену гілку та налаштувати відстеження однією командою.",
		"difficulty": "Легко",
		"category": "Співпраця",
		"hints": [
			"Використайте 'git push --set-upstream origin feature-login', щоб відправити та встановити upstream однією командою.",
			"Ви також можете використовувати скорочення 'git push -u origin feature-login'.",
			"Це створює віддалену гілку та налаштовує відстеження, тому майбутні відправлення не потребують вказування віддаленого репозиторія.",
			"Переконайтеся, що ви на гілці 'feature-login', коли виконуєте команду."
		]
	},
	{
		"id": 77,
		"title": "Встановити upstream до існуючої віддаленої гілки",
		"description": "Іноді у вас є локальна гілка, яка повинна відстежувати існуючу віддалену гілку, але відстежувальний зв'язок ще не встановлено. Це часто трапляється, коли ви створюєте локальну гілку з віддаленої гілки або під час роботи з гілками, створеними іншими членами команди.\n\nУ вас є локальна гілка 'feature-auth', і вже існує віддалена гілка 'origin/feature-auth'. Налаштуйте вашу локальну гілку для відстеження існуючої віддаленої гілки.",
		"difficulty": "Легко",
		"category": "Співпраця",
		"hints": [
			"Використайте 'git branch -u origin/feature-auth', щоб встановити upstream для поточної гілки.",
			"Ви також можете використовувати 'git branch --set-upstream-to=origin/feature-auth feature-auth' для більшої точності.",
			"Переконайтеся, що ви на гілці 'feature-auth', або вкажіть назву гілки в команді.",
			"Не використовуйте 'git push -u' для цього виклику — це для створення нових віддалених гілок."
		]
	},
	{
		"id": 78,
		"title": "Перебазувати гілку функціональності на main",
		"description": "У вас є гілка функціональності, яка була створена зі старої версії main. Відтоді main отримав нові коміти. Перебазування вашої гілки функціональності на останній main зберігає чисту, лінійну історію, відтворюючи ваші коміти функціональності поверх останніх комітів main, уникаючи непотрібних комітів злиття. Ця практика також забезпечує роботу вашої функціональності з найновішими змінами коду та робить історію проєкту легшою для читання та розуміння.\n\nПереключіться на гілку 'feature-payment' та перебазуйте її на 'main', щоб оновити її основу.",
		"difficulty": "Середньо",
		"category": "Співпраця",
		"hints": [
			"Спочатку переключіться на гілку функціональності командою 'git checkout feature-payment'.",
			"Потім використайте 'git rebase main', щоб перебазувати гілку функціональності на main.",
			"Це відтворить ваші коміти функціональності поверх останніх комітів main.",
			"Якщо є конфлікти, вирішіть їх та використайте 'git rebase --continue'."
		]
	},
	{
		"id": 79,
		"title": "Обробити стан відʼєднаного HEAD для безпечного дослідження",
		"description": "Коли ви переключаєтеся на конкретний коміт, ви входите в стан 'відʼєднаного HEAD', де ви не на жодній гілці. Це корисно для дослідження старого коду або тестування змін, але будь-які коміти, зроблені тут, можуть бути втрачені, якщо їх неправильно обробити. Безпечний спосіб працювати у відʼєднаному HEAD — це створити нову гілку, якщо ви хочете зберегти зміни.\n\nПереключіться на коміт 'abc5678', щоб увійти в стан відʼєднаного HEAD, потім створіть нову гілку з назвою 'exploration', щоб зробити це безпечним для розробки.",
		"difficulty": "Середньо",
		"category": "Співпраця",
		"hints": [
			"Використайте 'git checkout abc5678', щоб переключитися на конкретний коміт (це входить у відʼєднаний HEAD).",
			"Git попередить вас про стан відʼєднаного HEAD — це нормально.",
			"Створіть нову гілку командою 'git checkout -b exploration' або 'git switch -c exploration'.",
			"Це робить вашу позицію безпечною для створення комітів без втрати роботи."
		]
	},
	{
		"id": 80,
		"title": "Синхронізувати форк з upstream репозиторієм",
		"description": "У спільній розробці ви часто працюєте з форком оригінального репозиторія. Ваш форк (origin) може застаріти, коли оригінальний репозиторій (upstream) отримає нові коміти від інших учасників. Вам потрібно синхронізувати ваш форк з upstream репозиторієм, щоб залишатися в курсі останніх змін.\n\nУ вас є форкнутий репозиторій з 'origin', що вказує на ваш форк, та 'upstream', що вказує на оригінальний репозиторій. Upstream репозиторій має нові коміти, які вам потрібно отримати у ваш локальний репозиторій та відправити до вашого форка, щоб підтримувати його синхронізованим.",
		"difficulty": "Середньо",
		"category": "Співпраця",
		"hints": [
			"Спочатку завантажте останні зміни з upstream командою 'git fetch upstream'.",
			"Переконайтеся, що ви на вашій основній гілці командою 'git checkout main'.",
			"Зліть upstream зміни командою 'git merge upstream/main'.",
			"Відправте оновлену основну гілку до вашого форка командою 'git push origin main'.",
			"Цей робочий процес підтримує ваш форк синхронізованим з оригінальним репозиторієм."
		]
	}
]